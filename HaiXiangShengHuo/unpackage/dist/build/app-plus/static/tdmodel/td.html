<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
    <style>
        body {
            margin: 0;
        }
    </style>
</head>

<body>
	<div id="three" style="width: 100%; height: 100%;"></div>
    <script src="js/three.js"></script>
    <script src="js/GLTFLoader.js"></script>
	<script src="js/OrbitControls.js"></script>
    <script>
	
  //       const scene = new THREE.Scene();
  //       const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);

  //       const renderer = new THREE.WebGLRenderer();
  //       renderer.setSize(window.innerWidth, window.innerHeight);
  //       document.body.appendChild(renderer.domElement);

  //       const loader = new THREE.GLTFLoader();

  //       loader.load('./1.gltf', function (gltf) {
  //           scene.add(gltf.scene);
  //       }, undefined, function (error) {
  //           console.error(error);
  //       });
		
		// function animate() {
		//     requestAnimationFrame(animate);
		//     renderer.render(scene, camera);
		// }
		// animate();
		
		
		    const scene = new THREE.Scene()
		    scene.background = new THREE.Color('#eee')
		    scene.fog = new THREE.Fog('#eee', 20, 100)
		
		    const canvas = document.querySelector('#three')
		    const renderer = new THREE.WebGLRenderer({antialias: true })
		    renderer.shadowMap.enabled = true
			  const element = document.getElementById('three')
			  element.appendChild(renderer.domElement); // body元素中插入canvas对象
		
		    const camera = new THREE.PerspectiveCamera(
		      50,
		      window.innerWidth / window.innerHeight,
		      0.1,
		      1000
		    )
		    camera.position.z = 5
			scene.add(new THREE.AmbientLight(0x666666));
		    const gltfLoader = new THREE.GLTFLoader()
		    gltfLoader.load('1.glb', (gltf) => {
		      let model = gltf.scene
				console.log(123);
		      //遍历模型每部分
		      model.traverse((o) => {
		        //将图片作为纹理加载
		        let explosionTexture = new THREE.TextureLoader().load(
		          './1.png'
		        )
		        //调整纹理图的方向
		        explosionTexture.flipY = false
		        //将纹理图生成基础网格材质(MeshBasicMaterial)
		        const material = new THREE.MeshBasicMaterial({
		          map: explosionTexture,
		        })
		        //给模型每部分上材质
		        o.material = material
		        if (o.isMesh) {
		          o.castShadow = true
		          o.receiveShadow = true
		        }
		      })
		      scene.add(model);
			  
		    })
		
		    const hemLight = new THREE.HemisphereLight(0xffffff, 0xffffff, 0.6)
		    hemLight.position.set(0, 48, 0)
		    scene.add(hemLight)
		
		    const dirLight = new THREE.DirectionalLight(0xffffff, 0.6)
		    //光源等位置
		    dirLight.position.set(-10, 8, -5)
		    //可以产生阴影
		    dirLight.castShadow = true
		    dirLight.shadow.mapSize = new THREE.Vector2(1024, 1024)
		    scene.add(dirLight)
		
		    let floorGeometry = new THREE.PlaneGeometry(8000, 8000)
		    let floorMaterial = new THREE.MeshPhongMaterial({
		      color: 0x857ebb,
		      shininess: 0,
		    })
		
		    let floor = new THREE.Mesh(floorGeometry, floorMaterial)
		    floor.rotation.x = -0.5 * Math.PI
		    floor.receiveShadow = true
		    floor.position.y = -0.001
		    scene.add(floor)
		
		    const controls = new THREE.OrbitControls(camera, renderer.domElement)
		    controls.enableDamping = true
		
		    function animate() {
		      controls.update()
		      renderer.render(scene, camera)
		      requestAnimationFrame(animate)
		
		      if (resizeRendererToDisplaySize(renderer)) {
		        const canvas = renderer.domElement
		        camera.aspect = canvas.clientWidth / canvas.clientHeight
		        camera.updateProjectionMatrix()
		      }
		    }
		    animate()
		
		    function resizeRendererToDisplaySize(renderer) {
		      const canvas = renderer.domElement
		      var width = window.innerWidth
		      var height = window.innerHeight
		      var canvasPixelWidth = canvas.width / window.devicePixelRatio
		      var canvasPixelHeight = canvas.height / window.devicePixelRatio
		
		      const needResize =
		        canvasPixelWidth !== width || canvasPixelHeight !== height
		      if (needResize) {
		        renderer.setSize(width, height, false)
		      }
		      return needResize
		    }
		  
		
    </script>
	
</body>

</html>